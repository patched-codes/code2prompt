# Table of Contents
- code2prompt/__init__.py
- code2prompt/main.py
- code2prompt/core/template_processor.py
- code2prompt/core/generate_content.py
- code2prompt/core/process_files.py
- code2prompt/core/__init__.py
- code2prompt/core/process_file.py
- code2prompt/core/write_output.py
- code2prompt/utils/is_ignored.py
- code2prompt/utils/count_tokens.py
- code2prompt/utils/config.py
- code2prompt/utils/is_binary.py
- code2prompt/utils/create_template_directory.py
- code2prompt/utils/generate_markdown_content.py
- code2prompt/utils/is_filtered.py
- code2prompt/utils/get_gitignore_patterns.py
- code2prompt/utils/add_line_numbers.py
- code2prompt/utils/should_process_file.py
- code2prompt/utils/language_inference.py
- code2prompt/utils/logging_utils.py
- code2prompt/utils/parse_gitignore.py
- code2prompt/comment_stripper/strip_comments.py
- code2prompt/comment_stripper/sql_style.py
- code2prompt/comment_stripper/c_style.py
- code2prompt/comment_stripper/python_style.py
- code2prompt/comment_stripper/__init__.py
- code2prompt/comment_stripper/shell_style.py
- code2prompt/comment_stripper/r_style.py
- code2prompt/comment_stripper/matlab_style.py
- code2prompt/comment_stripper/html_style.py

## File: code2prompt/__init__.py

- Extension: .py
- Language: python
- Size: 0 bytes
- Created: 2024-06-28 09:26:36
- Modified: 2024-06-28 09:26:36

### Code

```python

```

## File: code2prompt/main.py

- Extension: .py
- Language: python
- Size: 4923 bytes
- Created: 2024-07-03 09:35:57
- Modified: 2024-07-03 09:35:57

### Code

```python
import logging
import click
from code2prompt.utils.config import load_config, merge_options
from code2prompt.utils.count_tokens import count_tokens
from code2prompt.core.generate_content import generate_content
from code2prompt.core.process_files import process_files
from code2prompt.core.write_output import write_output
from code2prompt.utils.create_template_directory import create_templates_directory
from code2prompt.utils.logging_utils import setup_logger, log_token_count, log_error


VERSION = "0.6.6"

DEFAULT_OPTIONS = {
    "path": [],
    "output": None,
    "gitignore": None,
    "filter": None,
    "exclude": None,
    "case_sensitive": False,
    "suppress_comments": False,
    "line_number": False,
    "no_codeblock": False,
    "template": None,
    "tokens": False,
    "encoding": "cl100k_base",
    "create_templates": False,
    "log_level": "INFO",  # Add default log level
}


@click.command()
@click.version_option(
    VERSION, "-v", "--version", message="code2prompt version %(version)s"
)
@click.option(
    "--path",
    "-p",
    type=click.Path(exists=True),
    multiple=True,
    help="Path(s) to the directory or file to process.",
)
@click.option(
    "--output", "-o", type=click.Path(), help="Name of the output Markdown file."
)
@click.option(
    "--gitignore",
    "-g",
    type=click.Path(exists=True),
    help="Path to the .gitignore file.",
)
@click.option(
    "--filter",
    "-f",
    type=str,
    help='Comma-separated filter patterns to include files (e.g., "*.py,*.js").',
)
@click.option(
    "--exclude",
    "-e",
    type=str,
    help='Comma-separated patterns to exclude files (e.g., "*.txt,*.md").',
)
@click.option(
    "--case-sensitive", is_flag=True, help="Perform case-sensitive pattern matching."
)
@click.option(
    "--suppress-comments",
    "-s",
    is_flag=True,
    help="Strip comments from the code files.",
    default=False,
)
@click.option(
    "--line-number",
    "-ln",
    is_flag=True,
    help="Add line numbers to source code blocks.",
    default=False,
)
@click.option(
    "--no-codeblock",
    is_flag=True,
    help="Disable wrapping code inside markdown code blocks.",
)
@click.option(
    "--template",
    "-t",
    type=click.Path(exists=True),
    help="Path to a Jinja2 template file for custom prompt generation.",
)
@click.option(
    "--tokens", is_flag=True, help="Display the token count of the generated prompt."
)
@click.option(
    "--encoding",
    type=click.Choice(["cl100k_base", "p50k_base", "p50k_edit", "r50k_base"]),
    default="cl100k_base",
    help="Specify the tokenizer encoding to use.",
)
@click.option(
    "--create-templates",
    is_flag=True,
    help="Create a templates directory with example templates.",
)
@click.option(
    "--log-level",
    type=click.Choice(
        ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], case_sensitive=False
    ),
    default="INFO",
    help="Set the logging level.",
)
def create_markdown_file(**cli_options):
    """
    Creates a Markdown file based on the provided options.

    This function orchestrates the process of reading files from the specified paths,
    processing them according to the given options (such as filtering, excluding certain files,
    handling comments, etc.), and then generating a Markdown file with the processed content.
    The output file name and location can be customized through the options.

    Args:
    **options (dict): Key-value pairs of options to customize the behavior of the function.
    Possible keys include 'path', 'output', 'gitignore', 'filter', 'exclude', 'case_sensitive',
    'suppress_comments', 'line_number', 'no_codeblock', 'template', 'tokens', 'encoding',
    'create_templates', and 'log_level'.

    Returns:
    None
    """
    # Load configuration from .code2promptrc files
    config = load_config(".")

    # Merge options: CLI takes precedence over config, which takes precedence over defaults
    options = merge_options(cli_options, config, DEFAULT_OPTIONS)

    # Set up logger with the specified log level
    _logger = setup_logger(level=getattr(logging, options["log_level"].upper()))

    if options["create_templates"]:
        create_templates_directory()
        return

    if not options["path"]:
        log_error(
            "Error: No path specified. Please provide a path using --path option or in .code2promptrc file."
        )
        return

    all_files_data = []
    for path in options["path"]:
        files_data = process_files({**options, "path": path})
        all_files_data.extend(files_data)

    content = generate_content(all_files_data, options)

    if options["tokens"]:
        token_count = count_tokens(content, options["encoding"])
        log_token_count(token_count)

    write_output(content, options["output"], copy_to_clipboard=True)


if __name__ == "__main__":
    # pylint: disable=no-value-for-parameter
    create_markdown_file()

```

## File: code2prompt/core/template_processor.py

- Extension: .py
- Language: python
- Size: 1622 bytes
- Created: 2024-06-29 08:08:33
- Modified: 2024-06-28 14:58:35

### Code

```python
from jinja2 import Template, Environment, FileSystemLoader
from prompt_toolkit import prompt
import re

def load_template(template_path):
    """
    Load a Jinja2 template from a file.

    Args:
        template_path (str): Path to the template file.

    Returns:
        str: The contents of the template file.
    """
    try:
        with open(template_path, 'r') as file:
            return file.read()
    except IOError as e:
        raise IOError(f"Error loading template file: {e}")

def get_user_inputs(template_content):
    """
    Extract user-defined variables from the template and prompt for input.

    Args:
        template_content (str): The contents of the template file.

    Returns:
        dict: A dictionary of user-defined variables and their values.
    """
    user_vars = re.findall(r'\{\{\s*(\w+)\s*\}\}', template_content)
    user_inputs = {}
    for var in user_vars:
        user_inputs[var] = prompt(f"Enter value for {var}: ")
    return user_inputs

def process_template(template_content, files_data, user_inputs):
    """
    Process the Jinja2 template with the given data and user inputs.

    Args:
        template_content (str): The contents of the template file.
        files_data (list): List of processed file data.
        user_inputs (dict): Dictionary of user-defined variables and their values.

    Returns:
        str: The processed template content.
    """
    try:
        template = Template(template_content)
        return template.render(files=files_data, **user_inputs)
    except Exception as e:
        raise ValueError(f"Error processing template: {e}")

```

## File: code2prompt/core/generate_content.py

- Extension: .py
- Language: python
- Size: 1216 bytes
- Created: 2024-06-29 08:09:07
- Modified: 2024-06-29 08:08:34

### Code

```python
from code2prompt.core.template_processor import get_user_inputs, load_template, process_template
from code2prompt.utils.generate_markdown_content import generate_markdown_content


def generate_content(files_data, options):
    """
    Generate content based on the provided files data and options.

    This function either processes a Jinja2 template with the given files data and user inputs
    or generates markdown content directly from the files data, depending on whether a
    template option is provided.

    Args:
        files_data (list): A list of dictionaries containing processed file data.
        options (dict): A dictionary containing options such as template path and whether
                        to wrap code inside markdown code blocks.

    Returns:
        str: The generated content as a string, either from processing a template or
             directly generating markdown content.
    """
    if options['template']:
        template_content = load_template(options['template'])
        user_inputs = get_user_inputs(template_content)
        return process_template(template_content, files_data, user_inputs)
    return generate_markdown_content(files_data, options['no_codeblock'])
```

## File: code2prompt/core/process_files.py

- Extension: .py
- Language: python
- Size: 1969 bytes
- Created: 2024-07-02 10:01:14
- Modified: 2024-07-02 10:01:14

### Code

```python
from pathlib import Path
from code2prompt.utils.get_gitignore_patterns import get_gitignore_patterns
from code2prompt.core.process_file import process_file
from code2prompt.utils.should_process_file import should_process_file

def process_files(options):
    """
    Processes files or directories based on the provided paths.

    Args:
    options (dict): A dictionary containing options such as paths, gitignore patterns,
                    and flags for processing files.

    Returns:
    list: A list of dictionaries containing processed file data.
    """
    files_data = []

    # Ensure 'path' is always a list for consistent processing
    paths = options['path'] if isinstance(options['path'], list) else [options['path']]

    for path in paths:
        path = Path(path)
        
        # Get gitignore patterns for the current path
        gitignore_patterns = get_gitignore_patterns(
            path.parent if path.is_file() else path,
            options['gitignore']
        )

        if path.is_file():
            # Process single file
            if should_process_file(path, gitignore_patterns, path.parent, options):
                result = process_file(
                    path,
                    options['suppress_comments'],
                    options['line_number'],
                    options['no_codeblock']
                )
                if result:
                    files_data.append(result)
        else:
            # Process directory
            for file_path in path.rglob("*"):
                if should_process_file(file_path, gitignore_patterns, path, options):
                    result = process_file(
                        file_path,
                        options['suppress_comments'],
                        options['line_number'],
                        options['no_codeblock']
                    )
                    if result:
                        files_data.append(result)

    return files_data
```

## File: code2prompt/core/__init__.py

- Extension: .py
- Language: python
- Size: 0 bytes
- Created: 2024-06-29 08:07:48
- Modified: 2024-06-29 08:07:48

### Code

```python

```

## File: code2prompt/core/process_file.py

- Extension: .py
- Language: python
- Size: 1877 bytes
- Created: 2024-06-29 08:08:14
- Modified: 2024-06-28 19:16:59

### Code

```python
from code2prompt.comment_stripper import strip_comments
from code2prompt.utils.add_line_numbers import add_line_numbers
from code2prompt.utils.language_inference import infer_language
from datetime import datetime

def process_file(file_path, suppress_comments, line_number, no_codeblock):
    """
    Processes a given file to extract its metadata and content.

    Parameters:
    - file_path (Path): The path to the file to be processed.
    - suppress_comments (bool): Flag indicating whether to remove comments from the file content.
    - line_number (bool): Flag indicating whether to add line numbers to the file content.
    - no_codeblock (bool): Flag indicating whether to disable wrapping code inside markdown code blocks.

    Returns:
    dict: A dictionary containing the file information and content.
    """
    file_extension = file_path.suffix
    file_size = file_path.stat().st_size
    file_creation_time = datetime.fromtimestamp(file_path.stat().st_ctime).strftime("%Y-%m-%d %H:%M:%S")
    file_modification_time = datetime.fromtimestamp(file_path.stat().st_mtime).strftime("%Y-%m-%d %H:%M:%S")
    language = "unknown"

    try:
        with file_path.open("r", encoding="utf-8") as f:
            file_content = f.read()
        
        language = infer_language(file_path.name)
        
        if suppress_comments and language != "unknown":
            file_content = strip_comments(file_content, language)
        
        if line_number:
            file_content = add_line_numbers(file_content)
    except UnicodeDecodeError:
        return None

    return {
        "path": str(file_path),
        "extension": file_extension,
        "language": language,
        "size": file_size,
        "created": file_creation_time,
        "modified": file_modification_time,
        "content": file_content,
        "no_codeblock": no_codeblock
    }

```

## File: code2prompt/core/write_output.py

- Extension: .py
- Language: python
- Size: 1302 bytes
- Created: 2024-07-03 09:45:13
- Modified: 2024-07-03 09:45:13

### Code

```python
from pathlib import Path
import click
import pyperclip
from code2prompt.utils.logging_utils import (
    log_output_created,
    log_error,
    log_clipboard_copy,
)


def write_output(content, output_path, copy_to_clipboard=True):
    """
    Writes the generated content to a file or prints it to the console,
    and copies the content to the clipboard.

    Parameters:
    - content (str): The content to be written, printed, and copied.
    - output_path (str): The path to the file where the content should be written.
                         If None, the content is printed to the console.
    - copy_to_clipboard (bool): Whether to copy the content to the clipboard.

    Returns:
    None
    """
    if output_path:
        try:
            with Path(output_path).open("w", encoding="utf-8") as output_file:
                output_file.write(content)
            log_output_created(output_path)
        except IOError as e:
            log_error(f"Error writing to output file: {e}")

    else:
        click.echo(content)

    log_clipboard_copy(success=True)
    if not copy_to_clipboard:
        return

    # Copy content to clipboard
    try:
        pyperclip.copy(content)
    # log_clipboard_copy(success=True)

    except Exception as _e:
        log_clipboard_copy(success=False)

```

## File: code2prompt/utils/is_ignored.py

- Extension: .py
- Language: python
- Size: 1223 bytes
- Created: 2024-07-03 09:06:58
- Modified: 2024-07-03 09:06:58

### Code

```python
from fnmatch import fnmatch
from pathlib import Path


from pathlib import Path
from fnmatch import fnmatch

def is_ignored(file_path: Path, gitignore_patterns: list, base_path: Path) -> bool:
    """
    Check if a file is ignored based on gitignore patterns.

    Args:
        file_path (Path): The path of the file to check.
        gitignore_patterns (list): List of gitignore patterns.
        base_path (Path): The base path to resolve relative paths.

    Returns:
        bool: True if the file is ignored, False otherwise.
    """
    relative_path = file_path.relative_to(base_path)
    for pattern in gitignore_patterns:
        pattern = pattern.rstrip("/")
        if pattern.startswith("/"):
            if fnmatch(str(relative_path), pattern[1:]):
                return True
            if fnmatch(str(relative_path.parent), pattern[1:]):
                return True
        else:
            for path in relative_path.parents:
                if fnmatch(str(path / relative_path.name), pattern):
                    return True
                if fnmatch(str(path), pattern):
                    return True
            if fnmatch(str(relative_path), pattern):
                return True
    return False
```

## File: code2prompt/utils/count_tokens.py

- Extension: .py
- Language: python
- Size: 571 bytes
- Created: 2024-06-29 08:08:57
- Modified: 2024-06-28 20:11:54

### Code

```python
import click
import tiktoken


def count_tokens(text: str, encoding: str) -> int:
    """
    Count the number of tokens in the given text using the specified encoding.

    Args:
        text (str): The text to tokenize and count.
        encoding (str): The encoding to use for tokenization.

    Returns:
        int: The number of tokens in the text.
    """
    try:
        encoder = tiktoken.get_encoding(encoding)
        return len(encoder.encode(text))
    except Exception as e:
        click.echo(f"Error counting tokens: {str(e)}", err=True)
        return 0
```

## File: code2prompt/utils/config.py

- Extension: .py
- Language: python
- Size: 1982 bytes
- Created: 2024-07-02 10:01:14
- Modified: 2024-07-02 10:01:14

### Code

```python
# code2prompt/config.py
import json
from pathlib import Path

def load_config(current_dir):
    """
    Load configuration from .code2promptrc files.
    Searches in the current directory and all parent directories up to the home directory.
    """
    config = {}
    current_path = Path(current_dir).resolve()
    home_path = Path.home()
    while current_path >= home_path:
        rc_file = current_path / '.code2promptrc'
        if rc_file.is_file():
            with open(rc_file, 'r', encoding='utf-8') as f:
                file_config = json.load(f)
                if 'path' in file_config and isinstance(file_config['path'], str):
                    file_config['path'] = file_config['path'].split(',')
                config.update(file_config)
        if current_path == home_path:
            break
        current_path = current_path.parent
    return config

def merge_options(cli_options: dict, config_options: dict, default_options: dict) -> dict:
    """
    Merge CLI options, config options, and default options.
    CLI options take precedence over config options, which take precedence over default options.
    """
    merged = default_options.copy()
    
    # Update with config options
    for key, value in config_options.items():
        if isinstance(value, dict) and isinstance(merged.get(key), dict):
            merged[key] = merge_options({}, value, merged[key])
        else:
            merged[key] = value
    
    # Update with CLI options, but only if they're different from the default
    for key, value in cli_options.items():
        if value != default_options.get(key):
            if isinstance(value, dict) and isinstance(merged.get(key), dict):
                merged[key] = merge_options(value, {}, merged[key])
            else:
                merged[key] = value
    
    # Special handling for 'path'
    if not merged['path'] and 'path' in config_options:
        merged['path'] = config_options['path']
    
    return merged
```

## File: code2prompt/utils/is_binary.py

- Extension: .py
- Language: python
- Size: 261 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
def is_binary(file_path):
    try:
        with open(file_path, "rb") as file:
            chunk = file.read(1024)
            return b"\x00" in chunk
    except IOError:
        print(f"Error: The file at {file_path} could not be opened.")
        return False
```

## File: code2prompt/utils/create_template_directory.py

- Extension: .py
- Language: python
- Size: 1574 bytes
- Created: 2024-06-29 08:09:19
- Modified: 2024-06-28 20:11:54

### Code

```python
from pathlib import Path


def create_templates_directory():
    """
    Create a 'templates' directory in the current working directory and
    populate it with example template files.
    """
    # Define the path for the templates directory
    templates_dir = Path.cwd() / "templates"

    # Create the templates directory if it doesn't exist
    templates_dir.mkdir(exist_ok=True)

    # Define example templates
    example_templates = {
        "basic.j2": """# Code Summary

{% for file in files %}
## {{ file.path }}

```{{ file.language }}
{{ file.content }}
```

{% endfor %}
""",
        "detailed.j2": """# Project Code Analysis

{% for file in files %}
## File: {{ file.path }}

- **Language**: {{ file.language }}
- **Size**: {{ file.size }} bytes
- **Last Modified**: {{ file.modified }}

### Code:

```{{ file.language }}
{{ file.content }}
```

### Analysis:
[Your analysis for {{ file.path }} goes here]

{% endfor %}
""",
        "custom.md": """# {{ project_name }}

{{ project_description }}

{% for file in files %}
## {{ file.path }}

{{ file_purpose }}

```{{ file.language }}
{{ file.content }}
```

{% endfor %}

## Next Steps:
{{ next_steps }}
""",
    }

    # Write example templates to files
    for filename, content in example_templates.items():
        file_path = templates_dir / filename
        with file_path.open("w") as f:
            f.write(content)

    print(f"Templates directory created at: {templates_dir}")
    print("Example templates added:")
    for filename, _ in example_templates.items():
        print(f"- {filename}")

```

## File: code2prompt/utils/generate_markdown_content.py

- Extension: .py
- Language: python
- Size: 1295 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
def generate_markdown_content(files_data, no_codeblock):
    """
    Generates a Markdown content string from the provided files data.

    Parameters:
    - files_data (list of dict): A list of dictionaries containing file information and content.
    - no_codeblock (bool): Flag indicating whether to disable wrapping code inside markdown code blocks.

    Returns:
    - str: A Markdown-formatted string containing the table of contents and the file contents.
    """
    table_of_contents = [f"- {file['path']}\n" for file in files_data]
    
    content = []
    for file in files_data:
        file_info = (
            f"## File: {file['path']}\n\n"
            f"- Extension: {file['extension']}\n"
            f"- Language: {file['language']}\n"
            f"- Size: {file['size']} bytes\n"
            f"- Created: {file['created']}\n"
            f"- Modified: {file['modified']}\n\n"
        )
        
        if no_codeblock:
            file_code = f"### Code\n\n{file['content']}\n\n"
        else:
            file_code = f"### Code\n\n```{file['language']}\n{file['content']}\n```\n\n"
        
        content.append(file_info + file_code)
    
    return (
        "# Table of Contents\n"
        + "".join(table_of_contents)
        + "\n"
        + "".join(content)
    )

```

## File: code2prompt/utils/is_filtered.py

- Extension: .py
- Language: python
- Size: 2208 bytes
- Created: 2024-07-03 08:15:50
- Modified: 2024-07-03 08:15:50

### Code

```python
from pathlib import Path
from fnmatch import fnmatch

def is_filtered(file_path: Path, include_pattern: str = "", exclude_pattern: str = "", case_sensitive: bool = False) -> bool:
    """
    Determine if a file should be filtered based on include and exclude patterns.
    
    Parameters:
    - file_path (Path): Path to the file to check
    - include_pattern (str): Comma-separated list of patterns to include files
    - exclude_pattern (str): Comma-separated list of patterns to exclude files
    - case_sensitive (bool): Whether to perform case-sensitive pattern matching
    
    Returns:
    - bool: True if the file should be included, False if it should be filtered out
    """
    def match_pattern(path: str, pattern: str) -> bool:
        if "**" in pattern:
            parts = pattern.split("**")
            return any(fnmatch(path, f"*{p}*") for p in parts if p)
        return fnmatch(path, pattern)

    def match_patterns(path: str, patterns: list) -> bool:
        return any(match_pattern(path, pattern) for pattern in patterns)

    # Convert file_path to string
    file_path_str = str(file_path)

    # Handle case sensitivity
    if not case_sensitive:
        file_path_str = file_path_str.lower()

    # Prepare patterns
    def prepare_patterns(pattern):
        if isinstance(pattern, str):
            return [p.strip().lower() for p in pattern.split(',') if p.strip()]
        elif isinstance(pattern, (list, tuple)):
            return [str(p).strip().lower() for p in pattern if str(p).strip()]
        else:
            return []

    include_patterns = prepare_patterns(include_pattern)
    exclude_patterns = prepare_patterns(exclude_pattern)

    # If no patterns are specified, include the file
    if not include_patterns and not exclude_patterns:
        return True

    # Check exclude patterns first (they take precedence)
    if match_patterns(file_path_str, exclude_patterns):
        return False

    # If include patterns are specified, the file must match at least one
    if include_patterns:
        return match_patterns(file_path_str, include_patterns)

    # If we reach here, there were no include patterns and the file wasn't excluded
    return True
```

## File: code2prompt/utils/get_gitignore_patterns.py

- Extension: .py
- Language: python
- Size: 1040 bytes
- Created: 2024-06-29 08:09:13
- Modified: 2024-06-28 20:11:54

### Code

```python
from code2prompt.utils.parse_gitignore import parse_gitignore
from pathlib import Path

def get_gitignore_patterns(path, gitignore):
    """
    Retrieve gitignore patterns from a specified path or a default .gitignore file.

    This function reads the .gitignore file located at the specified path or uses
    the default .gitignore file in the project root if no specific path is provided.
    It then parses the file to extract ignore patterns and adds a default pattern
    to ignore the .git directory itself.

    Args:
    path (Path): The root path of the project where the default .gitignore file is located.
    gitignore (Optional[str]): An optional path to a specific .gitignore file to use instead of the default.

    Returns:
    Set[str]: A set of gitignore patterns extracted from the .gitignore file.
    """
    if gitignore:
        gitignore_path = Path(gitignore)
    else:
        gitignore_path = Path(path) / ".gitignore"

    patterns = parse_gitignore(gitignore_path)
    patterns.add(".git")
    return patterns
```

## File: code2prompt/utils/add_line_numbers.py

- Extension: .py
- Language: python
- Size: 282 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
def add_line_numbers(code: str) -> str:
    lines = code.splitlines()
    max_line_number = len(lines)
    line_number_width = len(str(max_line_number))
    numbered_lines = [f"{i+1:{line_number_width}} | {line}" for i, line in enumerate(lines)]
    return "\n".join(numbered_lines)
```

## File: code2prompt/utils/should_process_file.py

- Extension: .py
- Language: python
- Size: 1208 bytes
- Created: 2024-07-02 10:49:31
- Modified: 2024-07-02 10:49:31

### Code

```python
import logging
from code2prompt.utils.is_binary import is_binary
from code2prompt.utils.is_filtered import is_filtered
from code2prompt.utils.is_ignored import is_ignored

logger = logging.getLogger(__name__)


def should_process_file(file_path, gitignore_patterns, root_path, options):
    """
    Determine whether a file should be processed based on several criteria.
    """
    logger.debug(f"Checking if should process file: {file_path}")

    if not file_path.is_file():
        logger.debug(f"Skipping {file_path}: Not a file.")
        return False

    if is_ignored(file_path, gitignore_patterns, root_path):
        logger.debug(
            f"Skipping {file_path}: File is ignored based on gitignore patterns."
        )
        return False

    if not is_filtered(
        file_path,
        options.get("filter", ""),
        options.get("exclude", ""),
        options.get("case_sensitive", False),
    ):
        logger.debug(f"Skipping {file_path}: File does not meet filter criteria.")
        return False

    if is_binary(file_path):
        logger.debug(f"Skipping {file_path}: File is binary.")
        return False

    logger.debug(f"Processing file: {file_path}")
    return True

```

## File: code2prompt/utils/language_inference.py

- Extension: .py
- Language: python
- Size: 3175 bytes
- Created: 2024-07-03 09:07:26
- Modified: 2024-07-03 09:07:26

### Code

```python
import os


def infer_language(filename: str) -> str:
    """
    Infers the programming language of a given file based on its extension.

    Parameters:
    - filename (str): The name of the file including its extension.

    Returns:
    - str: The inferred programming language as a lowercase string, e.g., "python".
           Returns "unknown" if the language cannot be determined.
    """
    _, extension = os.path.splitext(filename)
    extension = extension.lower()

    language_map = {
        ".c": "c",
        ".h": "c",
        ".cpp": "cpp",
        ".hpp": "cpp",
        ".cc": "cpp",
        ".cxx": "cpp",
        ".java": "java",
        ".js": "javascript",
        ".jsx": "javascript",
        ".ts": "typescript",
        ".tsx": "typescript",
        ".cs": "csharp",
        ".php": "php",
        ".go": "go",
        ".rs": "rust",
        ".kt": "kotlin",
        ".swift": "swift",
        ".scala": "scala",
        ".dart": "dart",
        ".py": "python",
        ".rb": "ruby",
        ".pl": "perl",
        ".pm": "perl",
        ".sh": "bash",
        ".bash": "bash",
        ".zsh": "zsh",
        ".ps1": "powershell",
        ".html": "html",
        ".htm": "html",
        ".xml": "xml",
        ".sql": "sql",
        ".m": "matlab",
        ".r": "r",
        ".lua": "lua",
        ".jl": "julia",
        ".f": "fortran",
        ".f90": "fortran",
        ".hs": "haskell",
        ".lhs": "haskell",
        ".ml": "ocaml",
        ".erl": "erlang",
        ".ex": "elixir",
        ".exs": "elixir",
        ".clj": "clojure",
        ".coffee": "coffeescript",
        ".groovy": "groovy",
        ".pas": "pascal",
        ".vb": "visualbasic",
        ".asm": "assembly",
        ".s": "assembly",
        ".lisp": "lisp",
        ".cl": "lisp",
        ".scm": "scheme",
        ".rkt": "racket",
        ".fs": "fsharp",
        ".d": "d",
        ".ada": "ada",
        ".nim": "nim",
        ".cr": "crystal",
        ".v": "verilog",
        ".vhd": "vhdl",
        ".tcl": "tcl",
        ".elm": "elm",
        ".zig": "zig",
        ".raku": "raku",
        ".perl6": "raku",
        ".p6": "raku",
        ".vim": "vimscript",
        ".ps": "postscript",
        ".prolog": "prolog",
        ".cobol": "cobol",
        ".cob": "cobol",
        ".cbl": "cobol",
        ".forth": "forth",
        ".fth": "forth",
        ".abap": "abap",
        ".apex": "apex",
        ".sol": "solidity",
        ".hack": "hack",
        ".sml": "standardml",
        ".purs": "purescript",
        ".idr": "idris",
        ".agda": "agda",
        ".lean": "lean",
        ".wasm": "webassembly",
        ".wat": "webassembly",
        ".j2": "jinja2",
        ".md": "markdown",
        ".tex": "latex",
        ".bib": "bibtex",
        ".yaml": "yaml",
        ".yml": "yaml",
        ".json": "json",
        ".toml": "toml",
        ".ini": "ini",
        ".cfg": "ini",
        ".conf": "ini",
        ".dockerfile": "dockerfile",
        ".docker": "dockerfile",
        '.txt': 'plaintext',
        '.csv': 'csv',
        '.tsv': 'tsv',
        '.log': 'log'
    }

    return language_map.get(extension, "unknown")

```

## File: code2prompt/utils/logging_utils.py

- Extension: .py
- Language: python
- Size: 6893 bytes
- Created: 2024-07-03 09:44:48
- Modified: 2024-07-03 09:44:48

### Code

```python
# code2prompt/utils/logging_utils.py

import sys
import logging
from colorama import init, Fore, Style

# Initialize colorama for cross-platform color support
init()

class ColorfulFormatter(logging.Formatter):
    """
    A custom formatter for logging messages that colors the output based on the log level
    and prefixes each message with an emoji corresponding to its severity.

    Attributes:
        COLORS (dict): Mapping of log levels to color codes.
        EMOJIS (dict): Mapping of log levels to emojis.

    Methods:
        format(record): Formats the given LogRecord.
    """
    COLORS = {
        'DEBUG': Fore.CYAN,
        'INFO': Fore.GREEN,
        'WARNING': Fore.YELLOW,
        'ERROR': Fore.RED,
        'CRITICAL': Fore.MAGENTA
    }

    EMOJIS = {
        'DEBUG': '🔍',
        'INFO': '✨',
        'WARNING': '⚠️',
        'ERROR': '💥',
        'CRITICAL': '🚨'
    }

    def format(self, record):
        """
        Formats the given LogRecord.

        Args:
            record (logging.LogRecord): The log record to format.

        Returns:
            str: The formatted log message.
        """
        color = self.COLORS.get(record.levelname, Fore.WHITE)
        emoji = self.EMOJIS.get(record.levelname, '')
        return f"{color}{emoji} {record.levelname}: {record.getMessage()}{Style.RESET_ALL}"

def setup_logger(name='code2prompt', level=logging.INFO):
    """
    Sets up and returns a logger with the specified name and logging level.

    Args:
        name (str): The name of the logger. Defaults to 'code2prompt'.
        level (int): The root logger level. Defaults to logging.INFO.

    Returns:
        logging.Logger: The configured logger instance.
    """
    local_logger = logging.getLogger(name)
    local_logger.setLevel(level)

    # Only add handler if there are none to prevent duplicate logging
    if not local_logger.handlers:
        # Create handlers
        c_handler = logging.StreamHandler(sys.stderr)
        c_handler.setFormatter(ColorfulFormatter())

        # Add handlers to the logger
        local_logger.addHandler(c_handler)

    return local_logger

# Create a global logger instance
logger = setup_logger()

def log_debug(message):
    """
    Logs a debug-level message.

    This function logs a message at the debug level, which is intended for detailed information,
    typically of interest only when diagnosing problems.

    Args:
        message (str): The message to log.

    Example:
        log_debug("This is a debug message")
    """
    logger.debug(message)

def log_info(message):
    """
    Logs an informational-level message.

    This function logs a message at the INFO level, which is used to provide general information
    about the program's operation without implying any particular priority.

    Args:
        message (str): The message to log.

    Example:
        log_info("Processing started")
    """
    logger.info(message)

def log_warning(message):
    """
    Logs a warning-level message.

    This function logs a message at the WARNING level, indicating that something unexpected
    happened, but did not stop the execution of the program.

    Args:
        message (str): The message to log as a warning.

    Example:
        log_warning("An error occurred while processing the file")
    """
    logger.warning(message)

def log_error(message):
    """
    Logs an error-level message.

    This function logs a message at the ERROR level, indicating that an error occurred
    that prevented the program from continuing normally.

    Args:
        message (str): The message to log as an error.

    Example:
        log_error("Failed to process file due to permission issues")
    """
    logger.error(message)

def log_critical(message):
    """
    Logs a critical-level message.

    This function logs a message at the CRITICAL level, indicating a severe error
    that prevents the program from functioning correctly.

    Args:
        message (str): The message to log as a critical error.

    Example:
        log_critical("A critical system failure occurred")
    """
    logger.critical(message)

def log_success(message):
    """
    Logs a success-level message.

    This function logs a message at the INFO level with a green color and a checkmark emoji,
    indicating that an operation was successful.

    Args:
        message (str): The message to log as a success.

    Example:
        log_success("File processed successfully")
    """
    logger.info(f"{Fore.GREEN}✅ SUCCESS: {message}{Style.RESET_ALL}")

def log_file_processed(file_path):
    """
    Logs a message indicating that a file has been processed.

    This function logs a message at the INFO level, indicating that a specific file has been processed.
    It uses a blue color and a file emoji for visual distinction.

    Args:
        file_path (str): The path to the file that was processed.

    Example:
        log_file_processed("/path/to/file.txt")
    """
    logger.info(f"{Fore.BLUE}📄 Processed: {file_path}{Style.RESET_ALL}")

def log_token_count(count):
    """
    Logs the total number of tokens processed.

    This function logs the total count of tokens processed by the application,
    using a cyan color and a token emoji for visual distinction.

    Args:
        count (int): The total number of tokens processed.

    Example:
        log_token_count(5000)
    """
    logger.info(f"{Fore.CYAN}🔢 Token count: {count}{Style.RESET_ALL}")

def log_output_created(output_path):
    """
    Logs a message indicating that an output file has been created.

    This function logs a message at the INFO level, indicating that an output file has been successfully created.
    It uses a green color and a folder emoji for visual distinction.

    Args:
        output_path (str): The path to the output file that was created.

    Example:
        log_output_created("/path/to/output/file.txt")
    """
    logger.info(f"{Fore.GREEN}📁 Output file created: {output_path}{Style.RESET_ALL}")

def log_clipboard_copy(success=True):
    """
    Logs whether the content was successfully copied to the clipboard.

    This function logs a message indicating whether the content copying to the clipboard was successful or not.
    It uses different emojis and colors depending on the success status.

    Args:
        success (bool): Indicates whether the content was successfully copied to the clipboard. Defaults to True.

    Examples:
        log_clipboard_copy(True)
            Logs: 📋 Content copied to clipboard
        log_clipboard_copy(False)
            Logs: 📋 Failed to copy content to clipboard
    """
    if success:
        logger.info(f"{Fore.GREEN}📋 Content copied to clipboard{Style.RESET_ALL}")
    else:
        logger.warning(f"{Fore.YELLOW}📋 Failed to copy content to clipboard{Style.RESET_ALL}")
```

## File: code2prompt/utils/parse_gitignore.py

- Extension: .py
- Language: python
- Size: 273 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
def parse_gitignore(gitignore_path):
    if not gitignore_path.exists():
        return set()
    with gitignore_path.open("r", encoding="utf-8") as file:
        patterns = set(line.strip() for line in file if line.strip() and not line.startswith("#"))
    return patterns
```

## File: code2prompt/comment_stripper/strip_comments.py

- Extension: .py
- Language: python
- Size: 1153 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
from .c_style import strip_c_style_comments
from .html_style import strip_html_style_comments
from .python_style import strip_python_style_comments
from .shell_style import strip_shell_style_comments
from .sql_style import strip_sql_style_comments
from .matlab_style import strip_matlab_style_comments
from .r_style import strip_r_style_comments

def strip_comments(code: str, language: str) -> str:
    if language in [
        "c", "cpp", "java", "javascript", "csharp", "php", "go", "rust", "kotlin", "swift", "scala", "dart",
    ]:
        return strip_c_style_comments(code)
    elif language in ["python", "ruby", "perl"]:
        return strip_python_style_comments(code)
    elif language in ["bash", "powershell", "shell"]:
        return strip_shell_style_comments(code)
    elif language in ["html", "xml"]:
        return strip_html_style_comments(code)
    elif language in ["sql", "plsql", "tsql"]:
        return strip_sql_style_comments(code)
    elif language in ["matlab", "octave"]:
        return strip_matlab_style_comments(code)
    elif language in ["r"]:
        return strip_r_style_comments(code)
    else:
        return code

```

## File: code2prompt/comment_stripper/sql_style.py

- Extension: .py
- Language: python
- Size: 336 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
import re

def strip_sql_style_comments(code: str) -> str:
    pattern = re.compile(
        r'--.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.DOTALL | re.MULTILINE,
    )
    return re.sub(
        pattern,
        lambda match: match.group(0) if match.group(0).startswith(("'", '"')) else "",
        code,
    )

```

## File: code2prompt/comment_stripper/c_style.py

- Extension: .py
- Language: python
- Size: 334 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
import re

def strip_c_style_comments(code: str) -> str:
    pattern = re.compile(
        r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.DOTALL | re.MULTILINE,
    )
    return re.sub(
        pattern,
        lambda match: match.group(0) if match.group(0).startswith(("'", '"')) else "",
        code,
    )

```

## File: code2prompt/comment_stripper/python_style.py

- Extension: .py
- Language: python
- Size: 357 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
import re

def strip_python_style_comments(code: str) -> str:
    pattern = re.compile(
        r'(?s)#.*?$|\'\'\'.*?\'\'\'|""".*?"""|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.MULTILINE,
    )
    return re.sub(
        pattern,
        lambda match: ("" if match.group(0).startswith(("#", "'''", '"""')) else match.group(0)),
        code,
    )

```

## File: code2prompt/comment_stripper/__init__.py

- Extension: .py
- Language: python
- Size: 389 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
from .c_style import strip_c_style_comments
from .html_style import strip_html_style_comments
from .python_style import strip_python_style_comments
from .shell_style import strip_shell_style_comments
from .sql_style import strip_sql_style_comments
from .matlab_style import strip_matlab_style_comments
from .r_style import strip_r_style_comments
from .strip_comments import strip_comments

```

## File: code2prompt/comment_stripper/shell_style.py

- Extension: .py
- Language: python
- Size: 720 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
def strip_shell_style_comments(code: str) -> str:
    lines = code.split("\n")
    new_lines = []
    in_multiline_comment = False
    for line in lines:
        if line.strip().startswith("#!"):  # Preserve shebang lines
            new_lines.append(line)
        elif in_multiline_comment:
            if line.strip().endswith("'"):
                in_multiline_comment = False
        elif line.strip().startswith(": '"):
            in_multiline_comment = True
        elif "#" in line:  # Remove single-line comments
            line = line.split("#", 1)[0]
            if line.strip():
                new_lines.append(line)
        else:
            new_lines.append(line)
    return "\n".join(new_lines).strip()

```

## File: code2prompt/comment_stripper/r_style.py

- Extension: .py
- Language: python
- Size: 323 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
import re

def strip_r_style_comments(code: str) -> str:
    pattern = re.compile(
        r'#.*?$|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.DOTALL | re.MULTILINE,
    )
    return re.sub(
        pattern,
        lambda match: match.group(0) if match.group(0).startswith(("'", '"')) else "",
        code,
    )

```

## File: code2prompt/comment_stripper/matlab_style.py

- Extension: .py
- Language: python
- Size: 328 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
import re

def strip_matlab_style_comments(code: str) -> str:
    pattern = re.compile(
        r'%.*?$|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.DOTALL | re.MULTILINE,
    )
    return re.sub(
        pattern,
        lambda match: match.group(0) if match.group(0).startswith(("'", '"')) else "",
        code,
    )

```

## File: code2prompt/comment_stripper/html_style.py

- Extension: .py
- Language: python
- Size: 148 bytes
- Created: 2024-06-28 14:58:35
- Modified: 2024-06-28 14:58:35

### Code

```python
import re

def strip_html_style_comments(code: str) -> str:
    pattern = re.compile(r"<!--.*?-->", re.DOTALL)
    return re.sub(pattern, "", code)

```

